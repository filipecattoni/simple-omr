import os, sys, glob, time, itertools, joblib
from enum import Enum

import numpy as np
import cv2 as cv

from sklearn import svm
from skimage.feature import hog

import helpers

class Symbols(Enum):
	empty                = 0
	unknown              = 1
	notehead_full        = 2
	notehead_empty       = 3
	rest_whole           = 4
	rest_half            = 5
	rest_quarter         = 6
	rest_eighth          = 7
	rest_sixteenth       = 8
	rest_thirtysecond    = 9
	accidental_flat      = 10
	accidental_natural   = 11
	accidental_sharp     = 12
	clef_alto            = 13
	clef_bass            = 14
	clef_treble          = 15

paths = [
	'empty',
	'unknown',
	'noteheads/full',
	'noteheads/empty',
	'rests/whole',
	'rests/half',
	'rests/quarter',
	'rests/eighth',
	'rests/sixteenth',
	'rests/thirtysecond',
	'accidentals/flat',
	'accidentals/natural',
	'accidentals/sharp',
	'clefs/alto',
	'clefs/bass',
	'clefs/treble'
]

symbol_names = [
	'',
	'',
	'',
	'',
	'',
	'',
	'quarter rests',
	'eighth rests',
	'sixteenth rests',
	'thirty-second rests',
	'flats',
	'naturals',
	'sharps',
	'alto clefs',
	'bass clefs',
	'treble clefs'
]

symbol_sizes = [
	[0, 0],
	[0, 0],
	[40, 35],
	[40, 35],
	[0, 0],
	[0, 0],
	[40, 70],
	[30, 50],
	[30, 70],
	[30, 90],
	[30, 70],
	[25, 50],
	[30, 70],
	[70, 160],
	[70, 160],
	[70, 160]
]

hog_or = 9
hog_ppc = [4, 4]
hog_cpb = [2, 2]

def generate_model():

	n_data_per_path = []
	train_ims = []
	labels = []

	for i in range(len(paths)):

		n_data_found = 0

		for file_path in glob.glob(os.path.join('training_data', paths[i], "*")):
			n_data_found = n_data_found+1
			labels.append(i)
			im = cv.imread(file_path, cv.IMREAD_GRAYSCALE)
			resized = cv.resize(im, (32, 32))
			im_hog = hog(resized,
				orientations=hog_or,
				pixels_per_cell=hog_ppc,
				cells_per_block=hog_cpb)
			train_ims.append(im_hog)

		n_data_per_path.append(n_data_found)

	clf = svm.SVC()
	clf.fit(train_ims, labels)

	return clf

def find_objs(image, image_sl, upper, lower):

	if not os.path.exists("model.svm"):

		print("Generating new model...")
		clf = generate_model()
		with open("model.svm", "wb") as f:
			joblib.dump(clf, f, protocol=5)
		print("New model generated at ./model.svm")

	else:

		print("Existing model found, loading...")
		with open("model.svm", "rb") as f:
			try:
				clf = joblib.load(f)
			except:
				print("Unable to load model.svm. Try deleting the file to generate a new model.")

	print("Detecting whole/half rests...")
	symbols = get_wholehalf(clf, image_sl, upper, lower)

	for s in symbols:
		print(s)

	return symbols

	print("Detecting whole/half notes...")
	for box in get_obj_boxes(clf, image, Symbols.notehead_empty.value):
		flags = find_flags(image, box)
		symbols.append([Symbols.notehead_empty.value, int((box[0]+box[2])/2), int((box[1]+box[3])/2), flags])

	print("Detecting other notes...")
	for box in get_obj_boxes(clf, image, Symbols.notehead_full.value):
		flags = find_flags(image, box)
		symbols.append([Symbols.notehead_full.value, int((box[0]+box[2])/2), int((box[1]+box[3])/2), flags])

	for i in range(Symbols.rest_quarter.value, len(Symbols)):
		print(f"Detecting {symbol_names[i]}...")
		for box in get_obj_boxes(clf, image, i):
			symbols.append([i, int((box[0]+box[2])/2), int((box[1]+box[3])/2)])

	for s in symbols:
		print(s)

def combine_overlaps(boxes, window_size):

	total_area = window_size[0] * window_size[1]
	combined_boxes = []
	for x, y in boxes:

		if not combined_boxes:
			combined_boxes.append([x, y, x+window_size[0], y+window_size[1]])
			continue

		# calculate overlap with existing boxes
		x2 = x + window_size[0]
		y2 = y + window_size[1]

		overlap = -1
		for i in range(len(combined_boxes)):

			xi1, yi1, xi2, yi2 = combined_boxes[i]

			xx1 = max(x, xi1)
			xx2 = min(x2, xi2)
			yy1 = max(y, yi1)
			yy2 = min(y2, yi2)

			if (xx2-xx1 < 0) or (yy2-yy1 < 0):
				continue

			overlap_area = (xx2-xx1) * (yy2-yy1)
			if overlap_area >= 0.5 * total_area:
				overlap = i
				break

		if overlap == -1:
			combined_boxes.append([x, y, x+window_size[0], y+window_size[1]])
		else:
			combined_boxes[i] = [
				min(x, combined_boxes[i][0]),
				min(y, combined_boxes[i][1]),
				max(x+window_size[0], combined_boxes[i][2]),
				max(y+window_size[1], combined_boxes[i][3])
			]

	return combined_boxes

def get_wholehalf(clf, img, upper, lower):

	init_boxes_whole = []
	init_boxes_half = []

	window_size = [32, lower-upper]

	for x in range(0, img.shape[1]-32, 8): 

		window = img[upper:lower, x:x+32]
		
		#cv.imwrite("data_temp/a1_{}_{}.png".format(x, 0), window)
		#continue

		resized = cv.resize(window, (32, 32))
		im_hog = hog(resized,
				orientations=hog_or,
				pixels_per_cell=hog_ppc,
				cells_per_block=hog_cpb)
		im_predict = clf.predict([im_hog])
		if im_predict == Symbols.rest_whole.value:
			init_boxes_whole.append([x, 0])
		if im_predict == Symbols.rest_half.value:
			init_boxes_half.append([x, 0])

	#sys.exit(0)

	symbols = []

	for box in combine_overlaps(init_boxes_whole, window_size):
		symbols.append([Symbols.rest_whole.value, int((box[0]+box[2])/2), int((box[1]+box[3])/2)])

	for box in combine_overlaps(init_boxes_half, window_size):
		symbols.append([Symbols.rest_half.value, int((box[0]+box[2])/2), int((box[1]+box[3])/2)])
	
	return symbols

def get_obj_boxes(clf, img, symbol):

	init_boxes = []
	window_size = symbol_sizes[symbol]

	# getting all bounding boxes in image

	for (x, y, window) in helpers.sliding_window(img, stepSize=8, windowSize=window_size):

		if (window.shape[1] < window_size[0]) or (window.shape[0] < window_size[1]):
			continue
		
		#cv.imwrite("data_temp/a1_{}_{}.png".format(x, y), window)
		#continue

		resized = cv.resize(window, (32, 32))
		im_hog = hog(resized,
				orientations=hog_or,
				pixels_per_cell=hog_ppc,
				cells_per_block=hog_cpb)
		im_predict = clf.predict([im_hog])
		if im_predict == symbol:
			init_boxes.append([x, y])

	#sys.exit(0)

	return combine_overlaps(init_boxes, window_size)

def find_flags(img, note_box):

	center_x = int((note_box[0] + note_box[2]) / 2)
	center_y = int((note_box[1] + note_box[3]) / 2)

	x_edge, y_dir = find_beam_dir(img, center_x, center_y)

	if y_dir == 0:
		return -1

	x_left, x_right = x_edge-5, x_edge+5
	y = center_y + (15*y_dir)

	flags_found = 0
	flag_detecting = False
	while True:

		if img[y][x_edge] != 0:
			break

		if flag_detecting:
			if not (img[y][x_left] == 0 or img[y][x_right] == 0):
				flag_detecting = False
		else:
			if img[y][x_left] == 0 or img[y][x_right] == 0:
				flags_found = flags_found+1
				flag_detecting = True

		y = y+y_dir
		if y<0 or y>len(img):
			break

	return flags_found

def find_beam_dir(img, x, y):

	x_threshold = 25
	y_threshold = 20
	beam_threshold = 15

	for x_dir in [-1, 1]:

		h_edge = x
		for i in range(1, x_threshold+1):
			h_edge = h_edge+x_dir
			if img[y][h_edge] != 0:
				h_edge = h_edge-x_dir
				break

		for y_dir in [-1, 1]:

			y_edge = y
			for i in range(1, y_threshold+1):
				y_edge = y_edge+y_dir
				if img[y_edge][x] != 0:
					y_edge = y_edge-y_dir
					break

			found = True
			for i in range(1, beam_threshold+1):
				if img[y_edge+(i*y_dir)][h_edge] != 0:
					found = False
					break

			if found:
				return h_edge, y_dir

	return 0, 0

def test_check_boxes(img, boxes):

	clone = img.copy()
	clone = cv.cvtColor(clone, cv.COLOR_GRAY2BGR)
	for x1, y1, x2, y2 in boxes:
		cv.rectangle(clone, 
			(x1, y1), 
			(x2, y2), 
			(0, 0, 255), 
			2)
	cv.imshow("Window", clone)
	cv.waitKey(0)